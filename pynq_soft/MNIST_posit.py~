#!/opt/python3.6/bin/python3.6
print('flashing MNIST MLP POSIT NN bitstream...')
from pynq import Overlay
import pynq.lib.dma
import numpy as np
from pynq import Xlnk
import time
import struct
import gzip
import sys

def read_compress_idx(filename):
    with gzip.open(filename, 'rb') as f:
        zero, data_type, dims = struct.unpack('>HBB', f.read(4))
        shape = tuple(struct.unpack('>I', f.read(4))[0] for d in range(dims))
        return np.fromstring(f.read(), dtype=np.uint8).reshape(shape)

def pretty_print_np_arr(np_arr):
    for i in np_arr:
        for j in i:
            if j==0:
                print('   ', end='')
            else :
                print("%03d" % j, end='')
        print()

def read_raw_28_28_posit_pic(filename):
    with open(filename, 'r') as f:
        t = f.readlines()
        t2 = []
        for i in t:
            t2.append(int(i, 16))
        return np.array(t2, dtype=np.uint32)

def read_train_arch_posit_16(filename):
    #with open(filename, 'rb') as f:
    return np.frombuffer(open(filename, "rb").read().decode('hex'), dtype=numpy.uint32).byteswap()

NUMBER_TO_CLASSIFY = int(sys.argv[1])

t = np.fromfile("posit_mnist", dtype=np.uint16).reshape((60000*784)).byteswap()
print(sizeof(t))
t.dtype = np.uint32
#np_arr = read_compress_idx('./train-images-idx3-ubyte.gz')
#pretty_print_np_arr(np_arr[NUMBER_TO_CLASSIFY])

# load the Overlay
overlay = Overlay('/home/xilinx/pynq/overlays/mnist/mnist.bit')

# load the NN DMA
NN_DMA = overlay.NN.DMA

NB_FRAMES = 60000

# size of buffer
# size in 32b WORDS
# one buffer is 1 pic to classify
# 28pix * 28pix / 2
N = 392 * NB_FRAMES

#img = np.full(N, 0x00000000, dtype=np.uint32)
#print(img.shape)
#print(img.dtype)

# np.copyto(img, np_arr_flatten)


# Allocate buffers for the input and output buffers
xlnk = Xlnk()
xlnk.cma_array(shape=(N,), dtype=np.uint32)
out_buffer = xlnk.cma_array(shape=(NB_FRAMES*5,), dtype=np.uint32)
#in_buffer = np.fromfile("posit_mnist", dtype=np.uint16).reshape((60000*784)).byteswap()
#in_buffer.dtype = np.uint32

# Copy the custom denormalized posits to the in buffer
#np.copyto(in_buffer, tmp)
np.copyto(in_buffer, t)
#np.copyto(in_buffer, img)

# Triger the DMA transfer and wait for result
start_time = time.time()

NN_DMA.sendchannel.transfer(in_buffer)
NN_DMA.recvchannel.transfer(out_buffer)

NN_DMA.sendchannel.wait()
NN_DMA.recvchannel.wait()

stop_time = time.time()
hw_exec_time = stop_time - start_time
throughput = (NB_FRAMES*784*2)/(1024*1024)/hw_exec_time
fps = NB_FRAMES/hw_exec_time
print('HW time(s): ', hw_exec_time)
print('throughput: ', throughput, "mBps")
print('FPS: ', fps)

#for i in out_buffer[-4:]:
#    print("0x{:08x}".format((i & 0xFFFFFFFF), '08x'))
with open("tmp", "wb") as f:
    f.write(out_buffer)

print("out posit values:")
for count,i in enumerate(out_buffer[-5:]):
    print(2*count, "0x{:04x}".format((i & 0xFFFF), '04x'))
    print(2*count + 1,"0x{:04x}".format((i>>16 & 0xFFFF), '04x'))

# Free the buffers
in_buffer.close()
out_buffer.close()
